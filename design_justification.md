To justify the design of the game, first a game loop was created as the "game engine" which runs the game. It contains attributes which control which actions the player is able to take, and whether or not those actions lead to the end of the game. Keeping this loop separate from the classes which contained code which created players or rooms made it makes logical sense because that level of detail is not important to the engine. The gameloop aggregates a GameSetup, which itself contains the players and Rooms. It also keeps the scanner which takes in Player commands separate from the code which runs those commands. Three attempts are allowed for the player to present the right books, and this adds some difficulty to the game-- as players cannot just keep trying random combinations until they are correct.  

GameSetup aggregates Rooms, Items, and Players, so that those elements can be abstracted away from the GameLoop. It contains a map of exits which store information about the rooms which connect to other rooms in each direction where there is an exit (all 4 directions are stored in an enum for easier error checking). It also contains the player and this is important so that the GameSetup can change the player's location and access the player's inventory when needed-- that would not be necessary for the processing of commands or the loop running the game, so the player is not an attribute of GameLoop. Lastly, GameSetup creates all the items, which it places into different Rooms. Having all of the relationships between Players, Items, and Rooms in this one class made editing the physical layout and placement of the player/items in that layout much easier. 

**Alternative design discussed**
The Room class contains attributes which allow a room to be identified and for rooms to have inventories. The enum Direction stores the 4 cardinal directions, and this was important as a design choice. An alternative would be to use a graph to relate rooms and create exit connections, but to mimic real-life rooms, one cannot move from one room to another room which is not physically adjacent to it, usually in an exit which is on a wall facing one of the 4 cardinal directions (as house rooms are typically rectangular). Thus, only 4 directions of exits and player movement were allowed. Rooms can also be created with an overloaded constructor to prompt a player for a password before becoming accessible. 

Like the Room class, the player class also contains an inventory, which allows for players to take or leave behind items in Rooms. Since the player must present 8 very specific items to the game in order to win, the existence of the player's inventory and its size limitations (up to 8 elements can be stored) is an important element of the difficulty in the game.Other than this, the player class has methods like grab and drop which allow it to modify which items are located in the inventory or dropped in rooms. Look allows players to examine an item. 

Both Player and Room classes contain a nameToItem map which associates the String names of items to the item object itself. It is through this map that GameLoop can accept the names of items, then have individual classes "convert" those Strings to references to real Item objects so that player commands can act on them. 

The Item class only has a name for identification, and description which can contain book titles or other information that is only available through the look command when an item is in the same room as the Player, or stored in the inventory. That adds another level of difficulty to the gameplay. 


